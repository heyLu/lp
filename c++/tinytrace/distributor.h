#ifndef DISTRIBUTOR_H
#define DISTRIBUTOR_H

#include <cstdlib>
#include <iostream>
#include <mutex>

#include "tracy/public/tracy/Tracy.hpp"

#include "vec3.h"

class distributor {
public:
  distributor(int w, int h) {
    done = false;
    c = 0;
    nx = w;
    ny = h;
    j = ny - 1;
    i = 0;
    lock = new std::mutex;
    randomize = false;
    seen = new bool[nx * ny + 1];
    linear_start = 0;
    for (int i = 0; i < nx * ny; i++) {
      seen[i] = false;
    }
  }

  bool next_pixel(int &count, int &x, int &y) {
    ZoneScoped;

    if (randomize) {
      lock->lock();
      int i = 0;

      {
        ZoneNamedN(random, "random", true);
        do {
          count = int(drand48() * nx * ny);
          i++;
        } while (seen[count] && i < 10);
      }
      if (seen[count]) {
        ZoneNamedN(find_linear, "find_linear", true);
        for (i = linear_start; i < nx * ny; i++) {
          if (!seen[i]) {
            linear_start = i;
            // std::cerr << "found at " << i;
            count = i;
            break;
          }
        }
      }
      seen[count] = true;
      x = count % nx;
      y = ny - (count / nx) - 1;

      bool end = (c++ <= nx * ny);
      lock->unlock();

      return end;
    } else {
      // this is basically a generator for i and j as generated by the following
      // loop:
      // for (int j = ny - 1; j >= 0; j--)
      //     for (int i = 0; i < nx; i++)

      if (c >= nx * ny || (i > nx && j < 0)) {
        done = true;
        return false;
      }

      lock->lock();

      count = c;
      if (i < nx) {
        x = i++;
        y = j;
      } else {
        x = 0;
        i = 1;
        y = --j;
      }

      c++;

      lock->unlock();

      return true;
    }
  };

  void continue_from(vec3 *image) {
    c = 0;
    for (int p = 0; p < nx * ny; p++) {
      vec3 px = image[p];
      if (px.r() >= 0.98 && px.g() >= 0.98 && px.b() >= 0.98) {
        seen[p] = false;
        continue;
      }

      seen[p] = true;
      c++;
    }
    std::cerr << c << ":";
  }

  void set_randomize(bool b) { randomize = b; }
  bool randomize;
  bool *seen;
  int linear_start;

  bool is_done() { return done; }
  int count() { return c; }
  int width() { return nx; }
  int height() { return ny; }

  bool done;
  int c;
  int nx;
  int ny;
  int i;
  int j;
  std::mutex *lock;
};

#endif
